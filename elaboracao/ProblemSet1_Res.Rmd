```{r packages}
# rm(list = ls())
library(tidyverse)
library(conflicted)
library(tictoc)     # timing
library(e1071)
```


https://en.wikipedia.org/wiki/Triangular_distribution

$$
f(x | a, b, c) = 
\begin{cases}
  0                         & \text{se} \; x < a \\
  \frac{2(x-a)}{(b-a)(c-a)} & \text{se} \; a \leq x < c \\
  \frac{2}{b-a}             & \text{se} \; x = c \\
  \frac{2(b-x)}{(b-a)(b-c)} & \text{se} \; c < x \leq b \\
  0                         & \text{se} \; x > b
\end{cases}
$$

```{r distribuição-triangular}
dtriang <- function(x, a = 0, b = 1, c= 0.5) {
  # a -> min, b -> max, c -> mode
  data.table::fcase(
    x < a | x > b    , 0,
    x <= c           , 2 * (x - a) / ((b - a) * (c - a)),
    x > c            , 2 * (b - x) / ((b - a) * (b - c)),
    TRUE             , NA_real_
  )
}
extraDistr::dtriang(1:10,1,10,3)
dtriang(1:10,1,10,3)
```

```{r}
aceitacao_rejeicao_triang <- function(n, min_value, max_value, mode_value) {
  k <- 0
  j <- 0
  y <- numeric(n)
  while (k < n) {
    u <- runif(1)
    j <- j + 1
    x <- runif(1, min_value, max_value)
    dist_trg <- dtriang(x, min_value, max_value, mode_value)
    if (u <= dist_trg) {
      k <- k + 1
      y[k] <- x
    }
  }
  return(y)
}


# aceitacao_rejeicao_triang <- function(n, a = 0, b = 1, c = 0.5) {
#   f <- \(x) dtriang(x, a, b, c)
#   # proposed function
#   g <- \(x) dunif(x, a, b)
#   # x (random variable) generator 
#   X <- \() runif(1, a, b)
#   # c: max of f, so that c >= f(x) / g(x) for all x
#   c <- 2 / (b - a)
#   # monte carlo (u(0, 1) <= f(x) / c*g(x) <=> u(0, c*g(x)) <= f(x))
#   u <- \() runif(n=1, min=0, max=1)
#   
#   ret <- c()
#   while(length(ret) < n) {
#     x <- X()
#     if (u() <= f(x)/(c*g(x)))
#       ret <- c(ret, x)
#   }
#   ret
# }
rtriang <- aceitacao_rejeicao_triang
```

```{r plots}
set.seed(2023)
tic()
  generated <- rtriang(10000, 0, 10, 5)
toc()
generated
```

```{r}
tri <- rtriang(100000, 1, 5, 3)
hist(tri, breaks=100, main="Triangle Distribution", xlab="x")
# Densidade dos NPA gerados
# density_plot <- ggplot(mapping= aes(x = generated)) +
#   geom_density(fill = "blue", alpha = 0.5) +
#   labs(x = "NPA", y = "Densidade") +
#   ggtitle("Densidade dos NPA Gerados")
# print(density_plot)
# # TODO gráfico (fiz um simples, mas seria interessante fazer o triângulo da distrib.)
```


## Exercício 2


https://en.wikipedia.org/wiki/Skewness

#### Quantile-based measures
$s_1=\displaystyle\frac{Q_3+Q_1-2Q_2}{Q_3-Q_1}$


#### Groeneveld and Meeden's coefficient
$s_2=\displaystyle\frac{(\mu-\nu)}{E(|X-\nu|)}$


### alínea a)

```{r}
set.seed(2023)

n_i <- 20
n_ii <- 100
n_iii <- 1000

# numero de amostras
n_amostras <- 100

# ?rt
# Student-t
amostras_i <- matrix(rt(n = n_i * n_amostras, df = n_i), nrow = n_i)
amostras_ii <- matrix(rt(n = n_ii * n_amostras, df = n_ii), nrow = n_ii)
amostras_iii <- matrix(rt(n = n_iii * n_amostras, df = n_iii), nrow = n_iii)
```

### alínea b)

```{r}
estim_s1 <- function(x){
  Q1 <- quantile(x, 0.25)
  Q2 <- quantile(x, 0.5)
  Q3 <- quantile(x, 0.75)
  return ((Q3+Q1-2*Q2)/(Q3-Q1))
}

estim_s2 <- function(x){
  miu <- mean(x)
  nu <- median(x)
  return ((miu - nu)/mean(abs(x - nu)))
}

# ?apply

(skewA_ai1 <- mean(apply(amostras_i, MARGIN = 2, FUN = estim_s1)))
(skewA_ai2 <- mean(apply(amostras_i, MARGIN = 2, FUN = estim_s2)))

(skewA_aii1 <- mean(apply(amostras_ii, MARGIN = 2, FUN = estim_s1)))
(skewA_aii2 <- mean(apply(amostras_ii, MARGIN = 2, FUN = estim_s2)))

(skewA_aiii1 <- mean(apply(amostras_iii, MARGIN = 2, FUN = estim_s1)))
(skewA_aiii2 <- mean(apply(amostras_iii, MARGIN = 2, FUN = estim_s2)))
```

### alínea c)

```{r}
# TODO, n me apeteceu
```


